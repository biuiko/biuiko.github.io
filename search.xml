<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[七个常见排序算法]]></title>
    <url>%2F2018%2F12%2F28%2F%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序这还是一个从大一(?)就开始学的最最最简单的排序算法。遍历数组一次性比较两个数值，如果他们排列顺序错误就将他们交换过来。 算法步骤（从小到大排序）： 从数组的第一个数开始，比较相邻的元素，如果前一个比后一个大，就将他们两个交换 每一轮冒泡结束后，本轮冒泡最大的数都将在数组能遍历到的最后一位，重复上一个步骤 稳定性：稳定排序 时间复杂度：O(n^2) 代码如下：123456789101112131415void Bubble_sort(vector&lt;int&gt; &amp;v)&#123; for(int i = 0 ; i &lt; v.size(); i++ ) &#123; for(int j = 0 ;j&lt;v.size()-i ;j++) &#123; if( v[j] &gt; v[j+1] ) //将排序错误的两个数字交换位置 &#123; int temp = v[j]; v[j] = v[j+1]; v[j+1] = temp; &#125; &#125; &#125;&#125; 选择排序也是一种超简单的排序算法。 在未排序的序列中找到最小（大）元素，存放已排序数列的末尾位置。 算法步骤（从大到小排序）： 第i次操作时，在数组v[i——n]中找出最大值，放在v[i]的位置上 操作n-1次排序完成 稳定性：稳定排序 时间复杂度：O(n^2) 代码如下：1234567891011121314void selection_sort(vector&lt;int&gt; &amp;v)&#123; for(int i = 0 ;i &lt;v.size();i++) &#123; int flag=i,temp=v[i]; for(int j = i+1; j&lt;v.size();j++) &#123; if(v[j] &gt; temp) flag = j,temp =v[j]; //找到最大值，记录最大值的下标 &#125; v[flag] = v[i]; v[i] = temp; &#125;&#125; 插入排序一种简单直观的排序算法。 它通过构建一个有序数列，将未排序的数据有序的插入有序数列中。 算法步骤（从小到大排序） 第一个数字是有序的 第i此操作，取出v[i]元素，遍历v[1——i],将第i个元素插入到j和k之间的位置，要求v[j]&lt;=v[i]且v[i]&lt;=v[k]; 操作n次后数组有序 稳定性：稳定排序 时间复杂度：O(n^2) 代码如下：1234567891011void insertion_sort(vector&lt;int&gt; &amp;v)&#123; for(int i =0 ;i &lt;v.size ;i++) &#123; int index = 0; while( index&lt;i &amp;&amp;&amp; v[index]&lt;=v[i]) index++; //找到合适的插入位置 for(int j=i;j&gt;=index;j--) //将插入位置及以后的元素向后移动 v[j] = v[j-1]; v[index] = v[i]; //将v[i]插入合适的位置 &#125;&#125; 希尔排序希尔排序在插排的基础上做了改进，是第一个时间复杂度小于O(n^2)的算法！ 他将一个序列分成若干个个子序列，然后做组内排序，知道一个组只有一个元素的时候，排序就结束啦。 算法步骤： 选择一个增量序列k(k1,k2,k3,k4)，k4=1 第i次操作选择ki作为增量，每隔ki个元素为一组，如v[ki],v[2ki],v[3ki]…为一组 对组内元素进行排序 直到增量为1排序完成 稳定性：不稳定排序算法 时间复杂度：O(n^(1.3——2)) 代码如下：123456789101112131415161718void shell_sort(vector&lt;int&gt; &amp;v)&#123; int increment = sqrt(v.size()) //给定初始增量 for(int inc = increment ; inc &gt;0 ; inc/=2)//增量一半一半递减直到增量为0 &#123; for(int i =inc ;i&lt;v.size() ;i++) //组内插排 &#123; int temp = v[i]; int j =inc-i; while(j&gt;=0 &amp;&amp; v[j]&gt;temp) &#123; v[j+inc] = v[j]; j-=inc; &#125; v[i] = temp; &#125; &#125;&#125; 快速排序我超级爱用的排序！好用！对冒泡排序用分治的思想进行了优化 通过一次排序使用一个关键字讲序列分为两个部分，比关键字小的左边站，比他大的右边站，然后在对左右两边在操作一次知道操作的区间为1时操作不动了，这个小区间的排序就完成啦。 算法步骤： 从数列中选出一个元素作为基准(一般为了避免时间复杂度到O(n^2),这个基准的选择都是用随机数) 数列中所有元素比基准小的放在左边，比基准大的放在右边 然后再递归的对分好的小区近在进行1，2步操作 知道区间不能再细分退出。 稳定性：不稳定的排序 时间复杂度：O（nlogn——n^2），平均复杂度为O(nlogn) 代码如下：123456789101112131415161718void quick_sort(vector&lt;int&gt; &amp;v,int low,int high)&#123; if(high&lt;=low) return; int left = low, right = high; int key = v[left] //将最左端端点作为基准 while(left != right) &#123; while( left&lt;right &amp;&amp; v[right] &gt;= key) //从后向前找到第一个小于key的数字的位置 right--; v[left] = v[right]; while(left &lt; right &amp;&amp; v[left] &lt;=key)//从前向后找到第一个大于key的数字的位置 left ++; v[right] = v[left]; &#125; v[left] = key ; //把基准放在正确的位置上 quick_sort(v,low,left-1); quick_sort(v,left+1,right);&#125; 归并排序我很少用这个排序，但在求逆序数的时候！如有神助！简直太好用了！我爱归并！归并排序现将序列拆分成几个有序的子序列，再将子序列合并起来使序列有序。 算法描述： 将长度为n的序列分成长度为n/2的两个子序列 若子序列无序则继续第一个步骤将该子序列分为两个子序列，知道子序列有序 将排好序的两个子序列合并最后变成一个最终的排序序列 稳定性：稳定排序 时间复杂度：O(nlogn) 代码如下：12345678910111213141516171819202122232425262728//按从小到大合并void merge(vector&lt;int&gt; &amp;v , int first ,int mid ,int last)&#123; int i = first ,j = mid+1; vector&lt;&lt;int&gt; temp; while(i&lt;=mid &amp;&amp;&amp; j&lt;=last) &#123; if(a[i]&gt;a[j]) temp.push_back(a[j++]); else temp.push_back(a[i++]); &#125; while(i&lt;=mid) temp.push_back(a[i++]); while(j&lt;=last) temp.push_back(a[j++]); for(int i = 0 ; i &lt; temp.size() ; i++) v[first+i] = temp[i];&#125;void mergesort(vector&lt;int&gt; &amp;v,int first,int last)&#123; if(first &lt; last) &#123; int mid = (first+last)&gt;&gt;1 ; mergesort(v , first , mid); //使左半部分有序 mergesort(v , mid+1 , last);//使右半部分有序 merge(v , first , mid , last); //将有序的左右部分合并 &#125;&#125; 堆排序啊终于写到最后一个了 先缓缓先缓缓 改天再续上嘿嘿]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HELLO iko!]]></title>
    <url>%2F2018%2F12%2F25%2FHELLO-iko%2F</url>
    <content type="text"><![CDATA[HELLO！想搭博客好久啦，今天终于开始啦冲鸭！快乐！]]></content>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
</search>
