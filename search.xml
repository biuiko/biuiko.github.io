<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>七个常见排序算法</title>
      <link href="/2018/12/28/%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/12/28/%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>这还是一个从大一(?)就开始学的最最最简单的排序算法。<br><br>遍历数组一次性比较两个数值，如果他们排列顺序错误就将他们交换过来。</p><p>算法步骤（从小到大排序）：</p><ul><li>从数组的第一个数开始，比较相邻的元素，如果前一个比后一个大，就将他们两个交换</li><li>每一轮冒泡结束后，本轮冒泡最大的数都将在数组能遍历到的最后一位，重复上一个步骤</li></ul><p>稳定性：稳定排序</p><p>时间复杂度：O(n^2)</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; v.size(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;v.size()-i ;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( v[j] &gt; v[j+<span class="number">1</span>] )         <span class="comment">//将排序错误的两个数字交换位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = v[j];</span><br><span class="line">                v[j] = v[j+<span class="number">1</span>];</span><br><span class="line">                v[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>也是一种超简单的排序算法。</p><p>在未排序的序列中找到最小（大）元素，存放已排序数列的末尾位置。</p><p>算法步骤（从大到小排序）：</p><ul><li>第i次操作时，在数组v[i——n]中找出最大值，放在v[i]的位置上</li><li>操作n-1次排序完成</li></ul><p>稳定性：稳定排序</p><p>时间复杂度：O(n^2)</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt;v.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag=i,temp=v[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;v.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j] &gt; temp)</span><br><span class="line">                flag = j,temp =v[j];        <span class="comment">//找到最大值，记录最大值的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        v[flag] = v[i];</span><br><span class="line">        v[i] = temp;                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>一种简单直观的排序算法。</p><p>它通过构建一个有序数列，将未排序的数据有序的插入有序数列中。</p><p>算法步骤（从小到大排序）</p><ul><li>第一个数字是有序的</li><li>第i此操作，取出v[i]元素，遍历v[1——i],将第i个元素插入到j和k之间的位置，要求v[j]&lt;=v[i]且v[i]&lt;=v[k];</li><li>操作n次后数组有序</li></ul><p>稳定性：稳定排序</p><p>时间复杂度：O(n^2)</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt;v.size ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( index&lt;i &amp;&amp;&amp; v[index]&lt;=v[i]) index++;    <span class="comment">//找到合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=index;j--)     <span class="comment">//将插入位置及以后的元素向后移动</span></span><br><span class="line">            v[j] = v[j<span class="number">-1</span>];</span><br><span class="line">        v[index] = v[i];            <span class="comment">//将v[i]插入合适的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序在插排的基础上做了改进，是第一个时间复杂度小于O(n^2)的算法！</p><p>他将一个序列分成若干个个子序列，然后做组内排序，知道一个组只有一个元素的时候，排序就结束啦。</p><p>算法步骤：</p><ul><li>选择一个增量序列k(k1,k2,k3,k4)，k4=1</li><li>第i次操作选择ki作为增量，每隔ki个元素为一组，如v[ki],v[2<em>ki],v[3</em>ki]…为一组</li><li>对组内元素进行排序</li><li>直到增量为1排序完成</li></ul><p>稳定性：不稳定排序算法</p><p>时间复杂度：O(n^(1.3——2))</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> increment = <span class="built_in">sqrt</span>(v.size())  <span class="comment">//给定初始增量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> inc = increment ; inc &gt;<span class="number">0</span> ; inc/=<span class="number">2</span>)<span class="comment">//增量一半一半递减直到增量为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =inc ;i&lt;v.size() ;i++)    <span class="comment">//组内插排</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = v[i];</span><br><span class="line">            <span class="keyword">int</span> j =inc-i;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; v[j]&gt;temp)</span><br><span class="line">            &#123;</span><br><span class="line">                v[j+inc] = v[j];</span><br><span class="line">                j-=inc;</span><br><span class="line">            &#125;</span><br><span class="line">            v[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>我超级爱用的排序！好用！对冒泡排序用分治的思想进行了优化</p><p>通过一次排序使用一个关键字讲序列分为两个部分，比关键字小的左边站，比他大的右边站，然后在对左右两边在操作一次知道操作的区间为1时操作不动了，这个小区间的排序就完成啦。</p><p>算法步骤：</p><ul><li>从数列中选出一个元素作为基准(一般为了避免时间复杂度到O(n^2),这个基准的选择都是用随机数)</li><li>数列中所有元素比基准小的放在左边，比基准大的放在右边</li><li>然后再递归的对分好的小区近在进行1，2步操作</li><li>知道区间不能再细分退出。</li></ul><p>稳定性：不稳定的排序</p><p>时间复杂度：O（nlogn——n^2），平均复杂度为O(nlogn)</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> left = low, right = high;</span><br><span class="line">    <span class="keyword">int</span> key = v[left]   <span class="comment">//将最左端端点作为基准</span></span><br><span class="line">    <span class="keyword">while</span>(left != right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( left&lt;right &amp;&amp; v[right] &gt;= key) <span class="comment">//从后向前找到第一个小于key的数字的位置</span></span><br><span class="line">            right--;</span><br><span class="line">        v[left] = v[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; v[left] &lt;=key)<span class="comment">//从前向后找到第一个大于key的数字的位置</span></span><br><span class="line">            left ++;</span><br><span class="line">        v[right] = v[left];</span><br><span class="line">    &#125;</span><br><span class="line">    v[left] = key ; <span class="comment">//把基准放在正确的位置上</span></span><br><span class="line">    quick_sort(v,low,left<span class="number">-1</span>);</span><br><span class="line">    quick_sort(v,left+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>我很少用这个排序，但在求逆序数的时候！如有神助！简直太好用了！我爱归并！<br>归并排序现将序列拆分成几个有序的子序列，再将子序列合并起来使序列有序。</p><p>算法描述：</p><ul><li>将长度为n的序列分成长度为n/2的两个子序列</li><li>若子序列无序则继续第一个步骤将该子序列分为两个子序列，知道子序列有序</li><li>将排好序的两个子序列合并最后变成一个最终的排序序列</li></ul><p>稳定性：稳定排序</p><p>时间复杂度：O(nlogn)</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按从小到大合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v , <span class="keyword">int</span> first ,<span class="keyword">int</span> mid ,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = first ,j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp;&amp; j&lt;=last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">            temp.push_back(a[j++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp.push_back(a[i++]);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)   temp.push_back(a[i++]);</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=last)  temp.push_back(a[j++]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; temp.size() ; i++)</span><br><span class="line">        v[first+i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first &lt; last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)&gt;&gt;<span class="number">1</span> ;</span><br><span class="line">        mergesort(v , first , mid); <span class="comment">//使左半部分有序</span></span><br><span class="line">        mergesort(v , mid+<span class="number">1</span> , last);<span class="comment">//使右半部分有序</span></span><br><span class="line">        merge(v , first , mid , last);   <span class="comment">//将有序的左右部分合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HELLO iko!</title>
      <link href="/2018/12/25/HELLO-iko/"/>
      <url>/2018/12/25/HELLO-iko/</url>
      
        <content type="html"><![CDATA[<h1 id="HELLO！"><a href="#HELLO！" class="headerlink" title="HELLO！"></a>HELLO！</h1><p>想搭博客好久啦，今天终于开始啦<br>冲鸭！快乐！</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
