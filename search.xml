<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[七大排序算法]]></title>
    <url>%2F2018%2F12%2F28%2F%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序这还是一个从大一(?)就开始学的最最最简单的排序算法。遍历数组一次性比较两个数值，如果他们排列顺序错误就将他们交换过来。 算法步骤（从小到大排序）： 从数组的第一个数开始，比较相邻的元素，如果前一个比后一个大，就将他们两个交换 每一轮冒泡结束后，本轮冒泡最大的数都将在数组能遍历到的最后一位，重复上一个步骤 稳定性：稳定排序 时间复杂度：O(n^2) 代码如下：123456789101112131415void Bubble_sort(vector&lt;&lt;int&gt; &amp;&amp;v)&#123; for(int i = 0 ; i &lt; v.size(); i++ ) &#123; for(int j = 0 ;j&lt;v.size()-i ;j++) &#123; if( v[j] &gt; v[j+1] ) //将排序错误的两个数字交换位置 &#123; int temp = v[j]; v[j] = v[j+1]; v[j+1] = temp; &#125; &#125; &#125;&#125; 选择排序也是一种超简单的排序算法。 在未排序的序列中找到最小（大）元素，存放已排序数列的末尾位置。 算法步骤（从大到小排序）： 第i次操作时，在数组v[i——n]中找出最大值，放在v[i]的位置上 操作n-1次排序完成 稳定性：稳定排序 时间复杂度：O(n^2) 代码如下：1234567891011121314void selection_sort(vector&lt;&lt;int&gt; &amp;&amp;v)&#123; for(int i = 0 ;i &lt;v.size();i++) &#123; int flag=i,temp=v[i]; for(int j = i+1; j&lt;v.size();j++) &#123; if(v[j] &gt; temp) flag = j,temp =v[j]; //找到最大值，记录最大值的下标 &#125; v[flag] = v[i]; v[i] = temp; &#125;&#125; 插入排序一种简单直观的排序算法。 它通过构建一个有序数列，将未排序的数据有序的插入有序数列中。 算法步骤（从小到大排序） 第一个数字是有序的 第i此操作，取出v[i]元素，遍历v[1——i],将第i个元素插入到j和k之间的位置，要求v[j]&lt;=v[i]且v[i]&lt;=v[k]; 操作n次后数组有序 稳定性：稳定排序 时间复杂度：O(n^2) 代码如下：1234567891011void insertion_sort(vector&lt;&lt;int&gt; &amp;&amp;v)&#123; for(int i =0 ;i &lt;v.size ;i++) &#123; int index = 0; while( index&lt;&lt;i &amp;&amp;&amp; v[index]&lt;=v[i]) index++; //找到合适的插入位置 for(int j=i;j&gt;=index;j--) //将插入位置及以后的元素向后移动 v[j] = v[j-1]; v[index] = v[i]; //将v[i]插入合适的位置 &#125;&#125; ###未完待续]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HELLO iko!]]></title>
    <url>%2F2018%2F12%2F25%2FHELLO-iko%2F</url>
    <content type="text"><![CDATA[HELLO！想搭博客好久啦，今天终于开始啦冲鸭！快乐！]]></content>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
</search>
